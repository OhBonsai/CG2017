<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D-Sierpinski-Rotate</title>

    <script src="math.js"></script>
</head>
<body>
    <div style="margin: 0 auto; width: 512px">
        <canvas id="c" style="border: 1px solid black; width: 512px; height: 512px; margin-top: 30px"></canvas>
    </div>

<script>
window.onload = function(){draw()};

const VS =`
#ifdef GL_ES
precision highp float;
#endif

attribute vec3 vPos;
attribute vec3 vNor;

uniform mat4 uModel;
uniform mat4 uProjection;
uniform mat4 uNormal;
uniform vec3 uLight;


varying float dotProduct;

void main(){
    vec4 transformedNormal = uNormal * vec4(vNor, 1.0);
    dotProduct = max(dot(transformedNormal.xyz, uLight), 0.0);
    gl_Position = uProjection*uModel*vec4(vPos, 1.);
}

`;

const FS =`
#ifdef GL_ES
precision highp float;
#endif

varying float dotProduct;

void main(){

    vec4 color = vec4(0.0, 0.0, 1.0, 1.0);
    float attenuation = 1.0 - gl_FragCoord.z;
    gl_FragColor = vec4(color.xyz * dotProduct * attenuation, color.a);
}
`;

const DIVIDE_TIME = 3;

let modelViewMatrix = new Matrix4x4();
let projectionMatrix = new Matrix4x4();
let viewerLocation = { x: 0.0, y: 0, z: 20.0 };
let rotationAroundX = 0.0;
let rotationAroundY = -90.0;
let gl;
let vertices = [];
let normals = [];

function draw(){
    divide(vertices, normals, [ 0.0, 3.0 * Math.sqrt(6), 0.0 ],
        [ -2.0 * Math.sqrt(3), -Math.sqrt(6), -6.0],
        [ -2.0 * Math.sqrt(3), -Math.sqrt(6), 6.0 ],
        [ 4.0 * Math.sqrt(3), -Math.sqrt(6), 0.0 ],
        DIVIDE_TIME);

    gl = document.getElementById('c').getContext('webgl');
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(1., 1., 1., 1.);

    let vs = initShader(VS, gl.VERTEX_SHADER);
    let fs = initShader(FS, gl.FRAGMENT_SHADER);
    let program = initProgram(vs, fs);
    gl.useProgram(program);

    let vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    let normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);


    let vPos = gl.getAttribLocation(program, 'vPos');
    gl.enableVertexAttribArray(vPos);
    let vNor = gl.getAttribLocation(program, 'vNor');
    gl.enableVertexAttribArray(vNor);

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(vPos, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.vertexAttribPointer(vNor, 3, gl.FLOAT, false, 0, 0);

    // one time light
    let uLight = gl.getUniformLocation(program, 'uLight');
    gl.uniform3fv(uLight, new Float32Array([0., 1., 1.]));

    let uModel = gl.getUniformLocation(program, 'uModel');
    let uProjection = gl.getUniformLocation(program, 'uProjection');
    let uNormal = gl.getUniformLocation(program, 'uNormal');

    drawScene(uModel, uProjection, uNormal);
    console.log(vertices);
    console.log(normals);
}

function drawScene(m, p, n){
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    projectionMatrix.loadIdentity();
    projectionMatrix.perspective(45, gl.canvas.width/gl.canvas.height, 11.0, 100.);

    modelViewMatrix.loadIdentity();
    modelViewMatrix.translate(-viewerLocation.x, -viewerLocation.y, -viewerLocation.z);
    modelViewMatrix.rotate(rotationAroundX, 1.0, 0.0, 0.0);
    modelViewMatrix.rotate(rotationAroundY, 0.,  1.,  0.);

    let normalMatrix = modelViewMatrix.copy();
    normalMatrix.invert();
    normalMatrix.transpose();

    gl.uniformMatrix4fv(n, false, new Float32Array(normalMatrix.elements));
    gl.uniformMatrix4fv(m, false, new Float32Array(modelViewMatrix.elements));
    gl.uniformMatrix4fv(p, false, new Float32Array(projectionMatrix.elements));

    gl.drawArrays(gl.TRIANGLES, 0, vertices.length/3);

    gl.flush();
}


function initShader(source, type){
    let s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);

    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
        alert('compile shader error: ' + gl.getShaderInfoLog(s));
        return null
    }else{
        return s
    }
}


function initProgram(vs, fs){
    let p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);

    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
        alert('compile program error: ' + gl.getProgramInfoLog(p));
        return null
    }else{
        return p
    }
}


function divide(v,n, a, b, c, d, time){
    if (time===0){
        let n1 = normalize(crossProduct(a, b, c));
        let n2 = normalize(crossProduct(a, c, d));
        let n3 = normalize(crossProduct(a, d, b));
        let n4 = normalize(crossProduct(d, c, b));
        let addN = [].concat(n1, n1, n1, n2, n2, n2, n3, n3, n3, n4, n4, n4);
        let addV = [].concat(a, b, c, a, c, d, a, d, b, d, c, b);

        n.push(...addN);
        v.push(...addV)


    }else{
        let ab = midpoint(a, b);
        let bc = midpoint(b, c);
        let ca = midpoint(c, a);
        let da = midpoint(d, a);
        let bd = midpoint(b, d);
        let dc = midpoint(d, c);

        divide(v, n, a, ab, ca, da, time-1);
        divide(v, n, ab, b, bc, bd, time-1);
        divide(v, n, ca, bc, c, dc, time-1);
        divide(v, n, da, bd, dc, d, time-1);
    }

};



function midpoint(point1, point2) {
    return [(point1[0] + point2[0]) / 2,
        (point1[1] + point2[1]) / 2,
        (point1[2] + point2[2]) / 2];
}

function vector(point1, point2) {
    return [ point2[0] - point1[0], point2[1] - point1[1], point2[2] - point1[2] ];
}


function crossProduct(point1, point2, point3) {
    let vector1 = vector(point1, point2),
        vector2 = vector(point1, point3);
    return [((vector1[1] * vector2[2]) - (vector2[1] * vector1[2])),
        ((vector1[2] * vector2[0]) - (vector2[2] * vector1[0])),
        ((vector1[0] * vector2[1]) - (vector2[0] * vector1[1]))];
}

/*
 * This function normalizes a 3D vector.
 */
function normalize (vector) {
    let length = Math.sqrt((vector[0] * vector[0]) +
        (vector[1] * vector[1]) + (vector[2] * vector[2]));
    return [ vector[0] / length, vector[1] / length, vector[2] / length ];
}



</script>

</body>
</html>